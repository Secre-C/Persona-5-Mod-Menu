import("../../Utilities/Math.flow");
import("Camera.msg");

// Global Variables
global float camRot_X;
global float camRot_Y;
global float camRot_Z;

global float camPos_X;
global float camPos_Y;
global float camPos_Z;

void CameraMenu()
{
    while (true && !PAD_CHK_PRESS(PadButton.L2))
    {
        int selection = DescriptionMenu(Title_Camera, Options_Camera);

        switch (selection)
        {
            case -1:
                return;
            case 0:
                CameraPosition();
                break;
            case 1:
                CameraFOVZoom();
                break;
            case 2:
                CameraUnlock();
                break;
            case 3:
                CameraLock();
                break;
            case 4:
                CAMERA_SHAKE_STOP();
                break;
        }
    }
}

void CameraPosition()
{
    DetectController();
    if (!controller)
        return;

    // Velocity to add per frame
    const float ADD_VELOCITY_PER_PRESS = 3f;

    float velocity_translate = 0f;
    float velocity_rot_x = 0f;
    float velocity_rot_y = 0f;
    float velocity_rot_z = 0f;
    int runs = 0;

    // Get current camera rotation
    GetCameraRotation();
    CameraLock();

    // Wait for all buttons to be released
    while (PAD_CHK_PRESS(PadButton.Any)) { SYNC(); }

    float rot_velocity_x = 0f;
    float rot_velocity_y = 0f;
    float rot_velocity_z = 0f;
    int rot_axis = 0;

    // Stop executing when Circle button is pressed
    while (!PAD_CHK_PRESS(PadButton.Circle))
    {
        // Bring velocity closer to zero
        ++runs;
        float multiplier = 1f;
        if (runs > 5)
        {
            multiplier = 1f;
            runs = 0;
            velocity_x /= 3f;
            velocity_y /= 3f;
            velocity_z /= 3f;
            rot_velocity_x /= 1.5f;
            rot_velocity_y /= 1.5f;
            rot_velocity_z /= 1.5f;
        }

        // If a button is pressed...
        if (PAD_CHK_PRESS(PadButton.Any))
        {
            // Multiply velocity
            if (PAD_CHK_PRESS(PadButton.Cross))
                multiplier *= 3f;
            if (PAD_CHK_PRESS(PadButton.Triangle))
                multiplier *= 5f;
            // Change rotation axis
            if (PAD_CHK_PRESS(PadButton.Select))
            {
                if (rot_axis == 2)
                    rot_axis = 0;
                else
                    rot_axis++;
                WAIT(10);
            }
            // Divide velocity
            if (PAD_CHK_PRESS(PadButton.Square))
                multiplier /= 10f;
            // Camera position north/east/south/west speed
            if (PAD_CHK_PRESS(PadButton.Up) || ANALOG_ASTICK_CHECK(0, 0, 0))
                velocity_z += ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.Right) || ANALOG_ASTICK_CHECK(0, 1, 0))
                velocity_x -= ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.Down) || ANALOG_ASTICK_CHECK(0, 2, 0))
                velocity_z -= ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.Left) || ANALOG_ASTICK_CHECK(0, 3, 0))
                velocity_x += ADD_VELOCITY_PER_PRESS * multiplier;
            // Camera position up/down speed
            if (PAD_CHK_PRESS(PadButton.R2))
                velocity_y += ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.L2))
                velocity_y -= ADD_VELOCITY_PER_PRESS * multiplier;

            // Camera rotation speed

            if (ANALOG_ASTICK_CHECK(1, 0, 0)) //rstick up
            {
                rot_velocity_x -= ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x + rot_velocity_x, camerarot_y, camerarot_z);
            }
            if (ANALOG_ASTICK_CHECK(1, 2, 0)) //rstick down
            {
                rot_velocity_x += ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x + rot_velocity_x, camerarot_y, camerarot_z);
            }

            if (ANALOG_ASTICK_CHECK(1, 1, 0)) //rstick right 
            {
                rot_velocity_y -= ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x, camerarot_y + rot_velocity_y, camerarot_z);
            }
            if (ANALOG_ASTICK_CHECK(1, 3, 0)) //rstick left 
            {
                rot_velocity_y += ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x, camerarot_y + rot_velocity_y, camerarot_z);
            }
            if (PAD_CHK_PRESS(PadButton.R1))
            {
                rot_velocity_z -= ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x, camerarot_y, camerarot_z + rot_velocity_z);
            }
            if (PAD_CHK_PRESS(PadButton.L1))
            {
                rot_velocity_z += ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x, camerarot_y, camerarot_z + rot_velocity_z);
            }
        }

        // Translate in direction camera is facing
        if (PAD_CHK_PRESS(PadButton.R2))
            velocity_translate -= ADD_VELOCITY_PER_PRESS * multiplier;
        if (PAD_CHK_PRESS(PadButton.L2))
            velocity_translate += ADD_VELOCITY_PER_PRESS * multiplier;
        TranslateCamera(velocity_translate);

        SYNC();
    }

    PrintCameraCoords();
}

void CameraFOVZoom()
{
    DetectController();
    if (!controller)
        return;

    CameraLock();

    const float ADD_VELOCITY_PER_PRESS = 3f;
    float velocity_fov = 0f;
    float velocity_zoom = 0f;
    float fov = FLD_CAMERA_GET_FOVY();
    int zoom = 1;
    int runs = 0;

    // Stop executing when Circle button is pressed
    while (!PAD_CHK_PRESS(PadButton.Circle))
    {
        // Bring velocity closer to zero
        ++runs;
        float multiplier = 2f;
        if (runs > 5)
        {
            multiplier = 1f;
            runs = 0;
            velocity_fov /= 2f;
            velocity_zoom /= 2f;
        }

        // Multiply velocity
        if (PAD_CHK_PRESS(PadButton.Cross))
            multiplier *= 2f;
        if (PAD_CHK_PRESS(PadButton.Triangle))
            multiplier *= 3f;
        // Divide velocity
        if (PAD_CHK_PRESS(PadButton.Square))
            multiplier /= 2f;

        // Camera position north/east/south/west speed
        if (PAD_CHK_TRIG(PadButton.Up))
            velocity_zoom += ADD_VELOCITY_PER_PRESS * multiplier;
        if (PAD_CHK_TRIG(PadButton.Down))
            velocity_zoom -= ADD_VELOCITY_PER_PRESS * multiplier;
        if (PAD_CHK_TRIG(PadButton.Right))
            velocity_fov += ADD_VELOCITY_PER_PRESS * multiplier;
        if (PAD_CHK_TRIG(PadButton.Left))
            velocity_fov -= ADD_VELOCITY_PER_PRESS * multiplier;

        fov += velocity_fov;
        zoom += velocity_zoom;

        FLD_CAMERA_SET_FOVY(fov);
        FLD_CAMERA_ZOOM(zoom);
        SYNC();
    }
}


void GetCameraRotation()
{
    float x;
    float y;
    float z;
    QuaternionToEuler(FLD_CAMERA_GET_X_ROT(), FLD_CAMERA_GET_Y_ROT(), FLD_CAMERA_GET_Z_ROT(), FLD_CAMERA_GET_W_ROT(), out x, out y, out z);
    camRot_X = x;
    camRot_Y = y;
    camRot_Z = z;
}

void GetCameraPosition()
{
    camPos_X = FLD_CAMERA_GET_X_POS();
    camPos_Y = FLD_CAMERA_GET_Y_POS();
    camPos_Z = FLD_CAMERA_GET_Z_POS();
}

void RotateCamera()
{
    float qX = 0f;
    float qY = 0f;
    float qZ = 0f;
    float qW = 0f;
    EulerToQuatDeg(camRot_X, camRot_Y, camRot_Z, out qX, out qY, out qZ, out qW);
    FLD_CAMERA_SET_ROT(qX, qY, qZ, qW);
}

void TranslateCamera(float speed)
{
    float forward_x = 0.0f;
    float forward_y = 0.0f;
    float forward_z = 1.0f;

    float tempX = 2.0f * (FLD_CAMERA_GET_Y_ROT() * forward_z - FLD_CAMERA_GET_Z_ROT() * forward_y);
    float tempY = 2.0f * (FLD_CAMERA_GET_Z_ROT() * forward_x - FLD_CAMERA_GET_X_ROT() * forward_z);
    float tempZ = 2.0f * (FLD_CAMERA_GET_X_ROT() * forward_y - FLD_CAMERA_GET_Y_ROT() * forward_x);

    forward_x += FLD_CAMERA_GET_W_ROT() * tempX + FLD_CAMERA_GET_Y_ROT() * tempZ - FLD_CAMERA_GET_Z_ROT() * tempY;
    forward_y += FLD_CAMERA_GET_W_ROT() * tempY + FLD_CAMERA_GET_Z_ROT() * tempX - FLD_CAMERA_GET_X_ROT() * tempZ;
    forward_z += FLD_CAMERA_GET_W_ROT() * tempZ + FLD_CAMERA_GET_X_ROT() * tempY - FLD_CAMERA_GET_Y_ROT() * tempX;

    // Normalize direction vector to ensure it has a length of 1
    float length = SQRT(forward_x * forward_x + forward_y * forward_y + forward_z * forward_z);
    forward_x /= length;
    forward_y /= length;
    forward_z /= length;

    // Apply the rotation to the translation vector
    camPos_X += (forward_x * speed);
    camPos_Y += (forward_y * speed);
    camPos_Z += (forward_z * speed);

    FLD_CAMERA_SET_POS(camPos_X, camPos_Y, camPos_Z);
}

void CameraUnlock()
{
    while (FLD_CAMERA_CHECK_LOCK() != 0)
        FLD_CAMERA_UNLOCK();
    FLD_CAMERA_BEHIND_UNLOCK();
}

void CameraLock()
{
    FLD_CAMERA_LOCK();
    FLD_CAMERA_BEHIND_LOCK();
}
