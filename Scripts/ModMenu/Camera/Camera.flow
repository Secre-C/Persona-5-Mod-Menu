import("../../Utilities/Math.flow");
import("Camera.msg");

// Global Variables
global float camerarot_x;
global float camerarot_y;
global float camerarot_z;

void CameraMenu()
{
    while (true && !PAD_CHK_PRESS(PadButton.L2))
    {
        int selection = DescriptionMenu(Title_Camera, Options_Camera);

        switch (selection)
        {
            case -1:
                return;
            case 0:
                CameraPosition();
                break;
            case 1:
                CameraFOVZoom();
                break;
            case 2:
                CameraUnlock();
                break;
            case 3:
                CameraLock();
                break;
            case 4:
                CAMERA_SHAKE_STOP();
                break;
        }
    }
}

void CameraPosition()
{
    DetectController();
    if (!controller)
        return;

    // Velocity to add per frame
    const float ADD_VELOCITY_PER_PRESS = 3f;

    float velocity_x = 0f;
    float velocity_y = 0f;
    float velocity_z = 0f;
    int runs = 0;

    // Get current camera rotation
    CameraGetRotation();
    CameraLock();

    // Wait for all buttons to be released
    while (PAD_CHK_PRESS(PadButton.Any)) { SYNC(); }

    float rot_velocity_x = 0f;
    float rot_velocity_y = 0f;
    float rot_velocity_z = 0f;
    int rot_axis = 0;

    // Stop executing when Circle button is pressed
    while (!PAD_CHK_PRESS(PadButton.Circle))
    {
        // Get current camera position
        float camera_x = FLD_CAMERA_GET_X_POS();
        float camera_y = FLD_CAMERA_GET_Y_POS();
        float camera_z = FLD_CAMERA_GET_Z_POS();

        // Bring velocity closer to zero
        ++runs;
        float multiplier = 1f;
        if (runs > 5)
        {
            multiplier = 1f;
            runs = 0;
            velocity_x /= 3f;
            velocity_y /= 3f;
            velocity_z /= 3f;
            rot_velocity_x /= 1.5f;
            rot_velocity_y /= 1.5f;
            rot_velocity_z /= 1.5f;
        }

        // If a button is pressed...
        if (PAD_CHK_PRESS(PadButton.Any))
        {
            // Multiply velocity
            if (PAD_CHK_PRESS(PadButton.Cross))
                multiplier *= 3f;
            if (PAD_CHK_PRESS(PadButton.Triangle))
                multiplier *= 5f;
            // Change rotation axis
            if (PAD_CHK_PRESS(PadButton.Select))
            {
                if (rot_axis == 2)
                    rot_axis = 0;
                else
                    rot_axis++;
                WAIT(10);
            }
            // Divide velocity
            if (PAD_CHK_PRESS(PadButton.Square))
                multiplier /= 10f;
            // Camera position north/east/south/west speed
            if (PAD_CHK_PRESS(PadButton.Up) || ANALOG_ASTICK_CHECK(0, 0, 0))
                velocity_z += ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.Right) || ANALOG_ASTICK_CHECK(0, 1, 0))
                velocity_x -= ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.Down) || ANALOG_ASTICK_CHECK(0, 2, 0))
                velocity_z -= ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.Left) || ANALOG_ASTICK_CHECK(0, 3, 0))
                velocity_x += ADD_VELOCITY_PER_PRESS * multiplier;
            // Camera position up/down speed
            if (PAD_CHK_PRESS(PadButton.R2))
                velocity_y += ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.L2))
                velocity_y -= ADD_VELOCITY_PER_PRESS * multiplier;

            // Camera rotation speed

            if (ANALOG_ASTICK_CHECK(1, 0, 0)) //rstick up
            {
                rot_velocity_x -= ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x + rot_velocity_x, camerarot_y, camerarot_z);
            }
            if (ANALOG_ASTICK_CHECK(1, 2, 0)) //rstick down
            {
                rot_velocity_x += ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x + rot_velocity_x, camerarot_y, camerarot_z);
            }

            if (ANALOG_ASTICK_CHECK(1, 1, 0)) //rstick right 
            {
                rot_velocity_y -= ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x, camerarot_y + rot_velocity_y, camerarot_z);
            }
            if (ANALOG_ASTICK_CHECK(1, 3, 0)) //rstick left 
            {
                rot_velocity_y += ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x, camerarot_y + rot_velocity_y, camerarot_z);
            }
            if (PAD_CHK_PRESS(PadButton.R1))
            {
                rot_velocity_z -= ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x, camerarot_y, camerarot_z + rot_velocity_z);
            }
            if (PAD_CHK_PRESS(PadButton.L1))
            {
                rot_velocity_z += ADD_VELOCITY_PER_PRESS * multiplier;
                CameraSetRotation(camerarot_x, camerarot_y, camerarot_z + rot_velocity_z);
            }
        }

        // Move camera in direction of velocity if not rotating
        FLD_CAMERA_SET_POS(camera_x + velocity_x, camera_y + velocity_y, camera_z + velocity_z);

        SYNC();
    }

    PrintCameraCoords();
}

void PrintCameraCoords()
{
    PUTS("Camera Pos X:");
    PUTF(FLD_CAMERA_GET_X_POS());
    PUTS("Camera Pos Y:");
    PUTF(FLD_CAMERA_GET_Y_POS());
    PUTS("Camera Pos Z:");
    PUTF(FLD_CAMERA_GET_Z_POS());
    float qX = 0f;
    float qY = 0f;
    float qZ = 0f;
    float qW = 0f;
    EulerToQuatDeg(camerarot_x, camerarot_y, camerarot_z, out qX, out qY, out qZ, out qW);
    PUTS("Camera Rot X:");
    PUTF(qX);
    PUTS("Camera Rot Y:");
    PUTF(qY);
    PUTS("Camera Rot Z:");
    PUTF(qZ);
    PUTS("Camera Rot W:");
    PUTF(qW);
}

void CameraFOVZoom()
{
    DetectController();
    if (!controller)
        return;

    CameraLock();

    const float ADD_VELOCITY_PER_PRESS = 3f;
    float velocity_fov = 0f;
    float velocity_zoom = 0f;
    float fov = FLD_CAMERA_GET_FOVY();
    int zoom = 1;
    int runs = 0;

    // Stop executing when Circle button is pressed
    while (!PAD_CHK_PRESS(PadButton.Circle))
    {
        // Bring velocity closer to zero
        ++runs;
        float multiplier = 1.10f;
        if (runs > 5)
        {
            multiplier = 1f;
            runs = 0;
            velocity_fov /= 2f;
            velocity_zoom /= 2f;
        }

        // Multiply velocity
        if (PAD_CHK_PRESS(PadButton.Cross))
            multiplier *= 2f;
        if (PAD_CHK_PRESS(PadButton.Triangle))
            multiplier *= 3f;
        // Divide velocity
        if (PAD_CHK_PRESS(PadButton.Square))
            multiplier /= 2f;

        // Camera position north/east/south/west speed
        if (PAD_CHK_PRESS(PadButton.Up))
            velocity_zoom += ADD_VELOCITY_PER_PRESS * multiplier;
        if (PAD_CHK_PRESS(PadButton.Down))
            velocity_zoom -= ADD_VELOCITY_PER_PRESS * multiplier;
        if (PAD_CHK_PRESS(PadButton.Right))
            velocity_fov += ADD_VELOCITY_PER_PRESS * multiplier;
        if (PAD_CHK_PRESS(PadButton.Left))
            velocity_fov -= ADD_VELOCITY_PER_PRESS * multiplier;

        fov += velocity_fov;
        zoom += velocity_zoom;

        FLD_CAMERA_SET_FOVY(fov);
        FLD_CAMERA_ZOOM(zoom);
        SYNC();
    }
}


void CameraGetRotation()
{
    float x;
    float y;
    float z;
    QuaternionToEuler(FLD_CAMERA_GET_X_ROT(), FLD_CAMERA_GET_Y_ROT(), FLD_CAMERA_GET_Z_ROT(), FLD_CAMERA_GET_W_ROT(), out x, out y, out z);
    camerarot_x = x;
    camerarot_y = y;
    camerarot_z = z;
}

void CameraSetRotation(float x, float y, float z)
{
    camerarot_x = x;
    camerarot_y = y;
    camerarot_z = z;
    float qX = 0f;
    float qY = 0f;
    float qZ = 0f;
    float qW = 0f;
    EulerToQuatDeg(camerarot_x, camerarot_y, camerarot_z, out qX, out qY, out qZ, out qW);
    FLD_CAMERA_SET_ROT(qX, qY, qZ, qW);
}

void CameraUnlock()
{
    while (FLD_CAMERA_CHECK_LOCK() != 0)
        FLD_CAMERA_UNLOCK();
    FLD_CAMERA_BEHIND_UNLOCK();
}

void CameraLock()
{
    FLD_CAMERA_LOCK();
    FLD_CAMERA_BEHIND_LOCK();
}
