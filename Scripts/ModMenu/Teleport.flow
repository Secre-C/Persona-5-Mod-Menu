void Teleport()
{
    // Get player resource handle
    int joker = FLD_PC_GET_RESHND(0);

    // Velocity to add per frame
    const float ADD_VELOCITY_PER_PRESS = 3f;

    float velocity_x = 0f;
    float velocity_y = 0f;
    float velocity_z = 0f;
    int runs = 0;

    // Wait for all buttons to be released
    while(PAD_CHK_PRESS(PadButton.Any)) { SYNC(); }

    // Stop executing when Circle button is pressed
    while (!PAD_CHK_PRESS(PadButton.Circle))
    {
        // Get current player rotation
        float rot_x = FLD_MODEL_GET_X_ROTATE(joker);
        float rot_y = FLD_MODEL_GET_Y_ROTATE(joker);
        float rot_z = FLD_MODEL_GET_Z_ROTATE(joker);

        // Bring velocity closer to zero
        ++runs;
        float multiplier = 1f;
        if (runs > 5)
        {
            multiplier = 1f;
            runs = 0;
            velocity_x /= 3f;
            velocity_y /= 3f;
            velocity_z /= 3f;
        }

        // If a button is pressed...
        if (PAD_CHK_PRESS(PadButton.Any))
        {
            // Multiply velocity
            if (PAD_CHK_PRESS(PadButton.Cross))
                multiplier *= 3f;
            if (PAD_CHK_PRESS(PadButton.Triangle))
                multiplier *= 5f;
            // Divide velocity
            if (PAD_CHK_PRESS(PadButton.Square))
                multiplier /= 10f;
            
            // Move forward/backward
            if (PAD_CHK_PRESS(PadButton.Up))
                velocity_z += ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.Down))
                velocity_z -= ADD_VELOCITY_PER_PRESS * multiplier;
            // Rotate left/right
            if (PAD_CHK_PRESS(PadButton.Left) || PAD_CHK_PRESS(PadButton.L1))
                FLD_MODEL_SET_ROTATE(joker, rot_x, rot_y + ADD_VELOCITY_PER_PRESS * multiplier, rot_z, 0);
            if (PAD_CHK_PRESS(PadButton.Right) || PAD_CHK_PRESS(PadButton.R1))
                FLD_MODEL_SET_ROTATE(joker, rot_x, rot_y - ADD_VELOCITY_PER_PRESS * multiplier, rot_z, 0);

            // Move up/down
            if (PAD_CHK_PRESS(PadButton.R2))
                velocity_y += ADD_VELOCITY_PER_PRESS * multiplier;
            if (PAD_CHK_PRESS(PadButton.L2))
                velocity_y -= ADD_VELOCITY_PER_PRESS * multiplier;
        }

        MovePlayer(velocity_x, velocity_y, velocity_z);

        SYNC();
    }
}


void MovePlayer(float x_offset, float y_offset, float z_offset)
{
    int joker = FLD_PC_GET_RESHND(0);

    // Get current player position
    float x = FLD_MODEL_GET_X_TRANSLATE(joker);
    float y = FLD_MODEL_GET_Y_TRANSLATE(joker);
    float z = FLD_MODEL_GET_Z_TRANSLATE(joker);
    float rot_x = FLD_MODEL_GET_X_ROTATE(joker);
    float rot_y = FLD_MODEL_GET_Y_ROTATE(joker);
    float rot_z = FLD_MODEL_GET_Z_ROTATE(joker);

    // Convert rotation angles to radians
    float cosR = COS(rot_x);
    float sinR = SIN(rot_x);
    float cosP = COS(rot_y);
    float sinP = SIN(rot_y);
    float cosY = COS(rot_z);
    float sinY = SIN(rot_z);

    // Calculate the elements of the rotation matrix
    float r11 = cosY * cosP;
    float r12 = cosY * sinP * sinR - sinY * cosR;
    float r13 = cosY * sinP * cosR + sinY * sinR;
    float r21 = sinY * cosP;
    float r22 = sinY * sinP * sinR + cosY * cosR;
    float r23 = sinY * sinP * cosR - cosY * sinR;
    float r31 = sinP * -1;
    float r32 = cosP * sinR;
    float r33 = cosP * cosR;

    // Apply the rotation to the translation vector
    x += (r11 * x_offset + r12 * y_offset + r13 * z_offset);
    y += (r21 * x_offset + r22 * y_offset + r23 * z_offset);
    z += (r31 * x_offset + r32 * y_offset + r33 * z_offset);

    FLD_MODEL_SET_TRANSLATE(joker, x, y, z, 0);
    FLD_MODEL_SYNC_TRANSLATE(joker);
    FLD_MODEL_SYNC_ROTATE(joker);
}